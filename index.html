<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>実車評価支援ツール</title>

<!-- PWA -->
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0ea5e9">

<!-- Leaflet（ローカル配置版） -->
<link rel="stylesheet" href="leaflet.css">

<style>
  html, body, #map { height: 100%; margin: 0; }
  #panel{
    position: absolute; top: 10px; left: 10px; z-index: 1000;
    background: #fff; padding: 10px 12px; border-radius: 12px;
    box-shadow: 0 2px 12px rgba(0,0,0,.2);
    font-family: system-ui, sans-serif; min-width: 280px; max-width: calc(100% - 20px);
  }
  #panel h1{ font-size:14px; margin:0 0 6px; font-weight:700 }
  .row{ display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap }
  .badge{ display:inline-block; background:#eef; border:1px solid #ccd; border-radius:6px; padding:1px 6px; font-size:11px }
  .small{ font-size:11px; color:#555 }
  button{ cursor:pointer }
  #recenter{ background:#0ea5e9; color:#fff; border:none; border-radius:8px; padding:6px 10px }
  .toggle{ display:inline-flex; align-items:center; gap:6px }
  input[type="file"]{ max-width: 100% }
</style>
</head>
<body>
  <div id="map"></div>

  <div id="panel">
    <h1>実車評価支援ツール</h1>

    <div class="row">
      <input type="file" id="file" accept=".kml,.kmz">
      <button id="clear">クリア</button>
      <button id="savegpx" title="走行軌跡をGPX保存">GPX保存</button>
    </div>

    <div class="row">
      <button id="track">位置追跡を開始</button>
      <button id="stop">停止</button>
      <button id="recenter">現在地へ</button>
      <label class="toggle"><input type="checkbox" id="follow" checked> 自動追従</label>
    </div>

    <div class="row">
      <label>通知距離: <span id="thv" class="badge">100m</span></label>
      <input id="th" type="range" min="20" max="300" value="100" style="flex:1">
    </div>

    <div class="row">
      <button id="tts">音声テスト</button>
      <span class="small" id="stat"></span>
    </div>

    <div class="small">
      ※ オンライン時に表示した地図は端末にキャッシュされ、以後はオフライン（電波圏外）でも表示できます。
    </div>
  </div>

  <!-- Service Worker 登録 -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    }
  </script>

  <!-- ライブラリ（ローカル） -->
  <script src="leaflet.js"></script>
  <script src="jszip.min.js"></script>
  <script src="togeojson.umd.js"></script>

  <script>
  // ====== 地図初期化 ======
  const map = L.map('map', { zoomControl: true }).setView([35.0, 135.0], 14);

  // OSMタイル（オンライン時表示。SWがキャッシュし、以後オフラインでも表示可）
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // ====== 状態/レイヤ ======
  let threshold = 100;                 // 通知距離[m]
  let points = [];                     // {latlng, name, desc, announced}
  let watchId = null;
  let meLayer = null;
  let routeLayer = null, pointLayer = null;
  let trackLine = null;               // 走行軌跡
  let trackPoints = [];               // GPX保存用
  let lastHere = null;
  let follow = true;

  // パネルの高さぶん自車位置が隠れにくいよう、追従時に上へオフセット
  const PANEL_OFFSET_PX = 110; // 端末により適宜調整

  // ====== UI参照 ======
  const elTh = document.getElementById('th');
  const elThV = document.getElementById('thv');
  const elStat = document.getElementById('stat');
  const elFollow = document.getElementById('follow');

  // ====== UIイベント ======
  elTh.addEventListener('input', ()=>{ threshold = +elTh.value; elThV.textContent = threshold + 'm'; });
  elFollow.addEventListener('change', ()=>{ follow = elFollow.checked; if (follow && lastHere) recenterWithOffset(lastHere); });
  document.getElementById('recenter').addEventListener('click', ()=>{ if(lastHere){ follow = true; elFollow.checked = true; recenterWithOffset(lastHere); } });
  document.getElementById('tts').addEventListener('click', ()=> speak('音声テストです'));
  document.getElementById('clear').addEventListener('click', clearAll);
  document.getElementById('track').addEventListener('click', startTrack);
  document.getElementById('stop').addEventListener('click', stopTrack);
  document.getElementById('file').addEventListener('change', onFile);
  document.getElementById('savegpx').addEventListener('click', saveGPX);

  // 地図操作したら追従OFF
  map.on('dragstart zoomstart', ()=>{ follow = false; elFollow.checked = false; });

  // ====== ユーティリティ ======
  function speak(text){
    try{
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'ja-JP';
      speechSynthesis.speak(u);
    }catch(_){}
  }
  function dist(a,b){
    const R = 6371000; const toRad = d=> d * Math.PI/180;
    const dlat = toRad(b.lat-a.lat), dlon = toRad(b.lng-a.lng);
    const s = Math.sin(dlat/2)**2 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(dlon/2)**2;
    return 2*R*Math.asin(Math.sqrt(s));
  }
  function recenterWithOffset(latlng){
    map.setView(latlng, map.getZoom(), { animate:false });
    // 上にオフセット（パネルに隠れにくい）
    map.panBy([0, -PANEL_OFFSET_PX], { animate:false });
  }

  // ====== KML/KMZ 読み込み ======
  async function onFile(ev){
    const f = ev.target.files[0];
    if(!f) return;
    const isKMZ = /\.kmz$/i.test(f.name);
    let kmlText = null;

    try{
      if(isKMZ){
        const buf = await f.arrayBuffer();
        const zip = await JSZip.loadAsync(buf);
        let kmlEntry = null;
        zip.forEach((p, entry)=>{ if(!kmlEntry && p.toLowerCase().endsWith('.kml')) kmlEntry = entry; });
        if(!kmlEntry) return alert('KMZ内にKMLがありません');
        kmlText = await kmlEntry.async('string');
      } else {
        kmlText = await f.text();
      }

      const kmlDom = new DOMParser().parseFromString(kmlText, 'text/xml');
      const gj = toGeoJSON.kml(kmlDom);

      // 既存クリア（軌跡は残す仕様にするならここは触らない）
      if(routeLayer) map.removeLayer(routeLayer);
      if(pointLayer) map.removeLayer(pointLayer);
      points = [];

      // ルート（Line系）
      const lineFeats = gj.features.filter(ft => ft.geometry && ft.geometry.type.includes('Line'));
      const lines = lineFeats.map(ft => L.polyline(ft.geometry.coordinates.map(c=>[c[1], c[0]]), {color:'#2b8a3e', weight:4}));
      routeLayer = L.layerGroup(lines).addTo(map);

      // チェックポイント（Point）
      const ptFeats = gj.features.filter(ft => ft.geometry && ft.geometry.type === 'Point');
      pointLayer = L.geoJSON({type:'FeatureCollection', features: ptFeats}, {
        pointToLayer: (ft, latlng)=> L.circleMarker(latlng, {radius:7, color:'#1e3a8a', weight:2, fillColor:'#60a5fa', fillOpacity:.9}),
        onEachFeature: (ft, layer)=>{
          const name = ft.properties.name || 'チェックポイント';
          const desc = ft.properties.description || '';
          layer.bindPopup(`<b>${name}</b><br>${desc}`);
          points.push({latlng: layer.getLatLng(), name, desc, announced:false});
        }
      }).addTo(map);

      const group = L.featureGroup([routeLayer, pointLayer]);
      map.fitBounds(group.getBounds().pad(0.2));

    }catch(err){
      console.error(err);
      alert('KML/KMZの読み込みに失敗しました');
    }
  }

  // ====== 追跡 ======
  function startTrack(){
    if(watchId) navigator.geolocation.clearWatch(watchId);
    watchId = navigator.geolocation.watchPosition(onPos, onErr, {
      enableHighAccuracy:true, maximumAge:1000, timeout:10000
    });
  }
  function stopTrack(){
    if(watchId){ navigator.geolocation.clearWatch(watchId); watchId=null; elStat.textContent=''; }
  }
  function clearAll(){
    if(routeLayer) { map.removeLayer(routeLayer); routeLayer=null; }
    if(pointLayer) { map.removeLayer(pointLayer); pointLayer=null; }
    if(trackLine)  { map.removeLayer(trackLine); trackLine=null; }
    points = [];
    trackPoints = [];
  }

  function onPos(pos){
    const {latitude, longitude, accuracy, speed} = pos.coords;
    const here = L.latLng(latitude, longitude);
    lastHere = here;

    // ステータス表示
    elStat.textContent = `精度 ${Math.round(accuracy||0)}m / 速度 ${speed!=null?Math.round(speed*3.6):'-'}km/h`;

    // 自車マーカー
    if(!meLayer){
      meLayer = L.circleMarker(here, {radius:8, color:'#dc2626', weight:3, fillColor:'#fecaca', fillOpacity:1}).addTo(map);
    }else{
      meLayer.setLatLng(here);
    }

    // 走行軌跡（赤）
    if(!trackLine){
      trackLine = L.polyline([here], {color:'#f00', weight:3}).addTo(map);
      trackPoints.push({lat: here.lat, lng: here.lng, time: new Date()});
    }else{
      trackLine.addLatLng(here);
      // 点が動いた時だけ記録（精度が悪い・停車時の微妙な揺れ対策）
      const last = trackPoints[trackPoints.length-1];
      if(!last || dist(L.latLng(last.lat,last.lng), here) > 3){
        trackPoints.push({lat: here.lat, lng: here.lng, time: new Date()});
      }
    }

    // 自動追従（パネルに隠れないよう上オフセット）
    if(follow){
      recenterWithOffset(here);
    }

    // チェックポイント到達判定
    for(const p of points){
      if(p.announced) continue;
      if(dist(here, p.latlng) <= threshold){
        p.announced = true;
        speak(p.name + '。 ' + p.desc);
      }
    }
  }

  function onErr(err){
    alert('位置取得に失敗: ' + err.message);
  }

  // ====== GPX 保存 ======
  function saveGPX(){
    if(trackPoints.length < 2){
      alert('走行軌跡がありません');
      return;
    }
    const pad = n=> n<10 ? '0'+n : ''+n;
    const toISO = (d)=>{
      // GPXはUTC推奨。Z付きISO8601にします
      const z = new Date(d.getTime() - d.getTimezoneOffset()*60000);
      return `${z.getUTCFullYear()}-${pad(z.getUTCMonth()+1)}-${pad(z.getUTCDate())}T${pad(z.getUTCHours())}:${pad(z.getUTCMinutes())}:${pad(z.getUTCSeconds())}Z`;
    };
    const gpxPts = trackPoints.map(p=> 
      `      <trkpt lat="${p.lat}" lon="${p.lng}"><time>${toISO(p.time)}</time></trkpt>`
    ).join('\n');
    const gpx =
`<?xml version="1.0" encoding="UTF-8"?>
<gpx creator="route-aid" version="1.1" xmlns="http://www.topografix.com/GPX/1/1">
  <trk>
    <name>route-aid track</name>
    <trkseg>
${gpxPts}
    </trkseg>
  </trk>
</gpx>`;
    const blob = new Blob([gpx], {type:'application/gpx+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date();
    a.href = url;
    a.download = `track_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.gpx`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  </script>
</body>
</html>
